{"index":"{\"keys\":[{\"path\":[\"title\"],\"id\":\"title\",\"weight\":1,\"src\":\"title\",\"getFn\":null},{\"path\":[\"body\"],\"id\":\"body\",\"weight\":1,\"src\":\"body\",\"getFn\":null},{\"path\":[\"slug\"],\"id\":\"slug\",\"weight\":1,\"src\":\"slug\",\"getFn\":null}],\"records\":[{\"i\":0,\"$\":{\"0\":{\"v\":\"JPA Cascade와 mappedBy의 혼동?(feat. orphanRemoval)\",\"n\":0.447},\"1\":{\"v\":\"\\n# JPA Cascade와 mappedBy를 공부할 때 오는 헷갈림(feat. orphanRemoval)\\n\\n## 개요\\n\\nJPA를 공부하면서 Cascade와 MappedBy에서 혼동(뭔가 기능상 영역이 겹쳐진다는 느낌)과 헷갈림, 모호함? 느꼈고, 그 내용을 정리해 보려고 한다.\\n\\n## JPA Cascade(영속성전의)란\\n\\n### JPA Cascade의 정의\\n\\nJPA Cascade는 영속성전의를 말한다. 부모엔티티와 자식엔티티가 연관관계가 설정된 상황에서 부모엔티티의 영속성 상태 변화가 발생할 경우 해당 부모엔티티에 연관관계로 연결된 자식엔티티에도 자동으로 영속성 상태변화를 전파시키는 것을 말한다.\\n\\nCascade는 엔티티 선언시 연관관계를 설정할 때 옵션으로 설정할수 있으며, 다음과 같은 다양한 옵션으로 설정이 가능하다.\\n\\n예를 들어 게시글과 게시글의 댓글이 있는경우, 게시글이 삭제될 때 해당 게시글의 댓글들이 같이 삭제되는 기능을 적용하고 싶을 때 유용하게 사용할 수 있는 기능이다.\\n\\n> 쉽게 말해 부모엔티티가 퍼시스턴스 영속화가 될 때 영속화가 되기 전의 자식엔티티를 부모엔티티에 연관관계로 설정하면, 부모엔티티 영속화 시점에 자식 엔티티도 함께 자동으로 퍼시스턴스 영속화가 되고, 부모엔티티가 삭제되면 해당 부모엔티티의 자식 엔티티도 함께 삭제 가 되는 것이다.\\n\\n> RDB에서 FK 설정시 사용되는 cascade와 비슷하다고 보면 이해가 슆다.\\n\\n### JPA Cascade 옵션 종류\\n\\n아래 6개 정도의 JPA Cascade 옵션종류가 존재하는데 ALL, PERSIST, REMOVE 정도만 사용된다고 한다.(인프런에서 김영환님은 주로 ALL, PERSIST 정도만 사용하신다고 한다.)\\n\\n- **CascadeType.ALL : 모두 적용**\\n\\n  - 부모엔티티의 모든 영속성상태 변화가 자식엔티티에 반영된다.\\n\\n- **CascadeType.PERSIST: 영속**\\n\\n  - 부모엔티티가 퍼시스턴스될때 자식엔티티도 함께 퍼시스턴트 상태가 된다.\\n\\n- **CascadeType.REMOVE: 삭제**\\n\\n  - 부모엔티티가 삭제될때 자식엔티티도 함께 삭제 된다.\\n\\n- CascadeType.MERGE: 병합\\n  - 부모엔티티가 merge 작업이 수행될 때 자식엔티티도 함게 merge 작업이 수행된다.\\n- CascadeType.REFRESH: REFRESH\\n  - entityManager.refersh() 작업으로 부모엔티티가 새로고침 될 때 자식엔티티도 함께 새로고침이 된다.(리프래쉬는 DB에서 해당 엔티티를 재조회 하는 것을 의미한다.)\\n- CascadeType.DETACH: DETACH\\n  - 부모엔티티가 영속성 콘텍스트에서 detach되면 자식엔티티도 함께 detach된다.\\n\\n### JPA Cascade 간단예제\\n\\n- Parent 엔티티\\n  - 1:다 관계에서 CascadeType.All이 지정되어 있다.\\n\\n```java\\npackage com.example.jpaexample.entity;\\n\\nimport jakarta.persistence.*;\\nimport lombok.Data;\\n\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\n@Data\\n@Entity\\npublic class Parent {\\n    @Id\\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\\n    @Column(name = \\\"id\\\", nullable = false)\\n    private Long id;\\n\\n    private String name;\\n\\n    @OneToMany(mappedBy = \\\"parent\\\", cascade = CascadeType.ALL)\\n    private List<Children> childrenList = new ArrayList<>();\\n\\n    public void addChildren(Children children){\\n        this.childrenList.add(children);\\n        children.setParent(this);\\n    }\\n\\n}\\n```\\n\\n- Children 엔티티\\n\\n```java\\npackage com.example.jpaexample.entity;\\n\\nimport jakarta.persistence.*;\\nimport lombok.Data;\\n\\n@Data\\n@Entity\\npublic class Children {\\n    @Id\\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\\n    @Column(name = \\\"id\\\", nullable = false)\\n    private Long id;\\n\\n    private String name;\\n\\n    @ManyToOne\\n    @JoinColumn(name=\\\"parent_id\\\")\\n    private Parent parent;\\n}\\n```\\n\\n- 위처럼 Parent와 Chidren 엔티티가 1:다 연관관계일 경우 아래처럼 Parent에 Childen을 모두 담아 Parent 객체의 한번의 저장으로 연관된 Children 엔티티를 한꺼번에 저장할수 있다.\\n\\n```java\\nParent parent = new Parent();\\nparent.setName(\\\"부모1\\\");\\n\\nChildren children1 = new Children();\\nchildren1.setName(\\\"자식1\\\");\\n\\nChildren children2 = new Children();\\nchildren2.setName(\\\"자식2\\\");\\n\\nparent.addChildren(children1);\\nparent.addChildren(children2);\\n\\nentityManager.persist(parent);\\n```\\n\\n## JPA Cacade 사용시 유의점\\n\\nCascade 옵션은 신중하게 사용해야 한다.\\n\\n무분별한 사용은 성능 저하나 데이터 무결성 문제를 야기할 수 있다.\\n\\n의도치 않게 고아 데이터가 생성되거나, 반대로 삭제되면 안되는 데이터가 삭제되어 버리는 동작이 발생할수 있으므로 JPA Cascade 기능은 프로젝트내에서 사용규칙을 정하고 구현하는 비지니스에 주의하여 적용해야 한다.\\n\\n> JPA Cascade의 사용시 주의해야 하는 경우의 예\\n> A라는 부모, B라는 부모가 동시에 C라는 자식엔티티를 연관관계로 갖을 때, 만약 A라는 엔티티에서 Cascade.REMOVE가 설정되어 있고 A가 삭제가 되는 경우 B부모 엔티티에서는 연관관계가 깨지는 상황이 발생하게 된다.\\n\\n> TIP.\\n> 부모엔티티와 자식엔티티의 라이프라이클이 거의 동일하고,\\n> 자식엔티티가 한 부모엔티티에만 속한경우에 편의성을 위해 JPA Cascade를 고려해 보자.\\n\\n### 고아객체\\n\\n- 고아객체란 부모엔티티와 연관관계가 끊어진 자식 엔티티를 말한다.\\n- 이런 고아객체를 자동으로 삭제하는 옵션 또한 존재한다.\\n  - orphanRemoval = true\\n\\n아래는 orphanRemoval의 예이다. 다음과 같이 설정된 경우 부모엔티티와 연관관계가 끊어진 Children 엔티티는 DB에서 지워지게 된다.\\n\\norphanRemoval 설정은 @OneToOne, @OneToMany 연관관계에서 설정이 가능하다.\\n\\n```java\\n@Data\\n@Entity\\npublic class Parent {\\n    @Id\\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\\n    @Column(name = \\\"id\\\", nullable = false)\\n    private Long id;\\n\\n    private String name;\\n\\n    @OneToMany(mappedBy = \\\"parent\\\", cascade = CascadeType.ALL)\\n    private List<Children> childrenList = new ArrayList<>();\\n\\n    public void addChildren(Children children){\\n        this.childrenList.add(children);\\n        children.setParent(this);\\n    }\\n\\n}\\n```\\n\\n- orphanRemoval = true 와 CascadeType.REMOVE의 차이점\\n  - 얼핏보면 두개가 동일한 기능을 하는것 처럼 보일수도 있지만 약간 차이가 있다.\\n  - CascadeType.Remove\\n    - 부모 엔티티가 삭제될 때, 연관된 자식 엔티티도 함께 삭제된다. 단순히 부모 엔티티가 삭제되었을 때, 관련된 자식 엔티티를 삭제하는 데 사용된다.\\n  - orphanRemoval = true\\n    - 부모 엔티티와의 관계가 끊어진 자식 엔티티를 삭제한다. 부모 엔티티가 삭제되지 않더라도, 관계가 끊어진 자식 엔티티는 삭제된다. 관계가 끊어진 \\\"고아\\\" 엔티티를 자동으로 삭제하는 기능을 제공한다.\\n\\n### Cascade.ALL + orphanRemoval =true 인 경우 부모엔티티는 자식엔티티의 모든 라이프사이클을 관리한다.\\n\\nCascade.ALL + orphanRemoval = true 가 된 경우 부모엔티티에서 자식엔티티의 라이프사이클을 전부 관리 할수 있다.\\n\\n이 경우 자식엔티티는 별도의 DAO, Repository 등을 생성하지 않고 이런 기능들을 부모엔티티에 넘길 수 있게 된다.\\n\\n도메인 주도 설계(DDD)의 Aggregate Root 개념을 구현 할 수 있다.\\n\\n## JPA mappedBy란\\n\\nmappedBy는 JPA에서 양방향 연관관계를 설정할 때, 연관관계의 주인이 누구인지 설정하는 것이다.\\n양방향 연관관계에서만 사용되므로 @OneToMay, @ManyToMany 에서만 설정이 가능하다.\\n연관관계의 주인이라는 말은 DB에서 연관관계를 설정하기 위해서는 참조키가 필요한데, 이 참조키를 실제 소유하는 엔티티를 연관관계의 주인 엔티티라 부른다.\\n즉 mappedBy 설정이란 이런 양방향 연관관계에서 어떤 엔티티에 실제 연관관계를 위한 참조키를 저장할 것인지를 설정하는 기능이다.\\n\\n아래 Parent 엔티티에 mappledBy = “parent” 라는 설정의 의미는 **나 Parent 엔티티는 양방향 연관관계의 주인이 아니다.** 라는 의미이다.\\n\\n나 말고 상대 엔티티인 Children 엔티티가 연관관계의 주인이며, 해당 엔티티의 parent 라는 프로퍼티가 실제 DB에서 참조키를 저장하는 컬럼이다 라고 명시한 것이다.\\n\\n```java\\n@Data\\n@Entity\\npublic class Parent {\\n    @Id\\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\\n    @Column(name = \\\"id\\\", nullable = false)\\n    private Long id;\\n\\n    private String name;\\n\\n    @OneToMany(mappedBy = \\\"parent\\\", cascade = CascadeType.ALL)\\n    private List<Children> childrenList = new ArrayList<>();\\n\\n    public void addChildren(Children children){\\n        this.childrenList.add(children);\\n        children.setParent(this);\\n    }\\n\\n}\\nData\\n@Entity\\npublic class Children {\\n    @Id\\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\\n    @Column(name = \\\"id\\\", nullable = false)\\n    private Long id;\\n\\n    private String name;\\n\\n    @ManyToOne\\n    @JoinColumn(name=\\\"parent_id\\\")\\n    private Parent parent;\\n}\\n```\\n\\n> mappedBy 사용시 햇갈리는 부분은 연관관계의 주인이 아닌 엔티티에 mappedBy 설정이 들어간다는 것이다.\\n> mappedBy 옵션이 보인다면 해당 엔티티의 반대편 엔티티가 연관관계의 주인이며, 그 주인 엔티티에 실제 FK 가 저장된다.\\n\\n### 연관관계 주인의 권한 : 연관관계를 설정할 수 있는 권한은 연관관계 주인이 갖는다.\\n\\n위 예제에서 연관관계의 주인은 Children이다. 즉 Children 엔티티에서 setParent 호출만이 실제 연관관계를 설정하게 된다.\\n\\n아래 Parent 부모엔티티의 addChildren 메소드를 보면 children.setParent 를 호출하는 것을 볼 수 있다. 만약 children.setParen 호출하지 않게 되면, Parent, Children 엔티티는 DB에 저장되지만 연관관계 없이 저장되게 된다.\\n\\n```java\\npublic void addChildren(Children children){\\n        this.childrenList.add(children);\\n        children.setParent(this);\\n}\\n```\\n\\n## 난 왜 Cascade와 mappedBy가 혼동되는가\\n\\n혼동을 테스트할 예제를 준비하겠다.\\n\\n엔티티\\n\\n```java\\n\\n@Data\\n@Entity\\npublic class Parent {\\n    @Id\\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\\n    @Column(name = \\\"id\\\", nullable = false)\\n    private Long id;\\n\\n    private String name;\\n\\n    @OneToMany(mappedBy = \\\"parent\\\", orphanRemoval = true)\\n    private List<Children> childrenList = new ArrayList<>();\\n\\n    public void addChildren(Children children){\\n        this.childrenList.add(children);\\n        children.setParent(this);\\n    }\\n\\n    public void removeChildren(Children children){\\n        this.childrenList.remove(children);\\n        children.setParent(null);\\n    }\\n}\\n\\n@Data\\n@Entity\\npublic class Children {\\n    @Id\\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\\n    @Column(name = \\\"id\\\", nullable = false)\\n    private Long id;\\n\\n    private String name;\\n\\n    @ManyToOne\\n    @JoinColumn(name=\\\"parent_id\\\")\\n    private Parent parent;\\n}\\n\\n```\\n\\n테스트 코드\\n\\n```java\\n// 테스트 코드\\n\\n```\\n\\n### 혼동1.\\n\\n### 혼동2.\\n\\n## 정리\\n\\n- Cascade와 mappedby 는 혼동될 것이 없다.\\n- Cascade는 영속성라이프사이클에 관련된 어떤 이벤트가 발생시 그 이벤트를 자식 엔티티에 전파할것인지에 대한 설정이다.\\n- mappedBy는 양방향 연관관계에서 연관관계의 주인을 명시하는 설정이다.\\n- mappedBy와 orphanRemoval = true를 같이 사용하면, 부모엔티티에서 연관관계 도우미?메소드를 통해 쉽게 제거 할수 있다.\\n- Cascade.ALL + orphanRemoval =true 같이 사용하면, 부모엔티티에서 자식엔티티의 라이프사이클을 완전히 컨트롤 할 수 있다.\\n  - 자식엔티티의 DAO, repository를 만들지 않을 수도 있다.\\n\\n## 참고자료\\n\\n- 인프런 - 자바 ORM 표준 JPA 프로그래밍 -기본편 (김영환)\\n- 책 - 자바 ORM 표준 JPA 프로그래밍 (김영환)\\n- chatGPT\\n\",\"n\":0.031},\"2\":{\"v\":\"/post/jpa_cascade_vs_mappedby/\",\"n\":1}}}]}","data":[{"id":"86734b89-024a-587a-9b82-9e9f0f2ff2c6","title":"JPA Cascade와 mappedBy의 혼동?(feat. orphanRemoval)","body":"\n# JPA Cascade와 mappedBy를 공부할 때 오는 헷갈림(feat. orphanRemoval)\n\n## 개요\n\nJPA를 공부하면서 Cascade와 MappedBy에서 혼동(뭔가 기능상 영역이 겹쳐진다는 느낌)과 헷갈림, 모호함? 느꼈고, 그 내용을 정리해 보려고 한다.\n\n## JPA Cascade(영속성전의)란\n\n### JPA Cascade의 정의\n\nJPA Cascade는 영속성전의를 말한다. 부모엔티티와 자식엔티티가 연관관계가 설정된 상황에서 부모엔티티의 영속성 상태 변화가 발생할 경우 해당 부모엔티티에 연관관계로 연결된 자식엔티티에도 자동으로 영속성 상태변화를 전파시키는 것을 말한다.\n\nCascade는 엔티티 선언시 연관관계를 설정할 때 옵션으로 설정할수 있으며, 다음과 같은 다양한 옵션으로 설정이 가능하다.\n\n예를 들어 게시글과 게시글의 댓글이 있는경우, 게시글이 삭제될 때 해당 게시글의 댓글들이 같이 삭제되는 기능을 적용하고 싶을 때 유용하게 사용할 수 있는 기능이다.\n\n> 쉽게 말해 부모엔티티가 퍼시스턴스 영속화가 될 때 영속화가 되기 전의 자식엔티티를 부모엔티티에 연관관계로 설정하면, 부모엔티티 영속화 시점에 자식 엔티티도 함께 자동으로 퍼시스턴스 영속화가 되고, 부모엔티티가 삭제되면 해당 부모엔티티의 자식 엔티티도 함께 삭제 가 되는 것이다.\n\n> RDB에서 FK 설정시 사용되는 cascade와 비슷하다고 보면 이해가 슆다.\n\n### JPA Cascade 옵션 종류\n\n아래 6개 정도의 JPA Cascade 옵션종류가 존재하는데 ALL, PERSIST, REMOVE 정도만 사용된다고 한다.(인프런에서 김영환님은 주로 ALL, PERSIST 정도만 사용하신다고 한다.)\n\n- **CascadeType.ALL : 모두 적용**\n\n  - 부모엔티티의 모든 영속성상태 변화가 자식엔티티에 반영된다.\n\n- **CascadeType.PERSIST: 영속**\n\n  - 부모엔티티가 퍼시스턴스될때 자식엔티티도 함께 퍼시스턴트 상태가 된다.\n\n- **CascadeType.REMOVE: 삭제**\n\n  - 부모엔티티가 삭제될때 자식엔티티도 함께 삭제 된다.\n\n- CascadeType.MERGE: 병합\n  - 부모엔티티가 merge 작업이 수행될 때 자식엔티티도 함게 merge 작업이 수행된다.\n- CascadeType.REFRESH: REFRESH\n  - entityManager.refersh() 작업으로 부모엔티티가 새로고침 될 때 자식엔티티도 함께 새로고침이 된다.(리프래쉬는 DB에서 해당 엔티티를 재조회 하는 것을 의미한다.)\n- CascadeType.DETACH: DETACH\n  - 부모엔티티가 영속성 콘텍스트에서 detach되면 자식엔티티도 함께 detach된다.\n\n### JPA Cascade 간단예제\n\n- Parent 엔티티\n  - 1:다 관계에서 CascadeType.All이 지정되어 있다.\n\n```java\npackage com.example.jpaexample.entity;\n\nimport jakarta.persistence.*;\nimport lombok.Data;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Data\n@Entity\npublic class Parent {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\", nullable = false)\n    private Long id;\n\n    private String name;\n\n    @OneToMany(mappedBy = \"parent\", cascade = CascadeType.ALL)\n    private List<Children> childrenList = new ArrayList<>();\n\n    public void addChildren(Children children){\n        this.childrenList.add(children);\n        children.setParent(this);\n    }\n\n}\n```\n\n- Children 엔티티\n\n```java\npackage com.example.jpaexample.entity;\n\nimport jakarta.persistence.*;\nimport lombok.Data;\n\n@Data\n@Entity\npublic class Children {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\", nullable = false)\n    private Long id;\n\n    private String name;\n\n    @ManyToOne\n    @JoinColumn(name=\"parent_id\")\n    private Parent parent;\n}\n```\n\n- 위처럼 Parent와 Chidren 엔티티가 1:다 연관관계일 경우 아래처럼 Parent에 Childen을 모두 담아 Parent 객체의 한번의 저장으로 연관된 Children 엔티티를 한꺼번에 저장할수 있다.\n\n```java\nParent parent = new Parent();\nparent.setName(\"부모1\");\n\nChildren children1 = new Children();\nchildren1.setName(\"자식1\");\n\nChildren children2 = new Children();\nchildren2.setName(\"자식2\");\n\nparent.addChildren(children1);\nparent.addChildren(children2);\n\nentityManager.persist(parent);\n```\n\n## JPA Cacade 사용시 유의점\n\nCascade 옵션은 신중하게 사용해야 한다.\n\n무분별한 사용은 성능 저하나 데이터 무결성 문제를 야기할 수 있다.\n\n의도치 않게 고아 데이터가 생성되거나, 반대로 삭제되면 안되는 데이터가 삭제되어 버리는 동작이 발생할수 있으므로 JPA Cascade 기능은 프로젝트내에서 사용규칙을 정하고 구현하는 비지니스에 주의하여 적용해야 한다.\n\n> JPA Cascade의 사용시 주의해야 하는 경우의 예\n> A라는 부모, B라는 부모가 동시에 C라는 자식엔티티를 연관관계로 갖을 때, 만약 A라는 엔티티에서 Cascade.REMOVE가 설정되어 있고 A가 삭제가 되는 경우 B부모 엔티티에서는 연관관계가 깨지는 상황이 발생하게 된다.\n\n> TIP.\n> 부모엔티티와 자식엔티티의 라이프라이클이 거의 동일하고,\n> 자식엔티티가 한 부모엔티티에만 속한경우에 편의성을 위해 JPA Cascade를 고려해 보자.\n\n### 고아객체\n\n- 고아객체란 부모엔티티와 연관관계가 끊어진 자식 엔티티를 말한다.\n- 이런 고아객체를 자동으로 삭제하는 옵션 또한 존재한다.\n  - orphanRemoval = true\n\n아래는 orphanRemoval의 예이다. 다음과 같이 설정된 경우 부모엔티티와 연관관계가 끊어진 Children 엔티티는 DB에서 지워지게 된다.\n\norphanRemoval 설정은 @OneToOne, @OneToMany 연관관계에서 설정이 가능하다.\n\n```java\n@Data\n@Entity\npublic class Parent {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\", nullable = false)\n    private Long id;\n\n    private String name;\n\n    @OneToMany(mappedBy = \"parent\", cascade = CascadeType.ALL)\n    private List<Children> childrenList = new ArrayList<>();\n\n    public void addChildren(Children children){\n        this.childrenList.add(children);\n        children.setParent(this);\n    }\n\n}\n```\n\n- orphanRemoval = true 와 CascadeType.REMOVE의 차이점\n  - 얼핏보면 두개가 동일한 기능을 하는것 처럼 보일수도 있지만 약간 차이가 있다.\n  - CascadeType.Remove\n    - 부모 엔티티가 삭제될 때, 연관된 자식 엔티티도 함께 삭제된다. 단순히 부모 엔티티가 삭제되었을 때, 관련된 자식 엔티티를 삭제하는 데 사용된다.\n  - orphanRemoval = true\n    - 부모 엔티티와의 관계가 끊어진 자식 엔티티를 삭제한다. 부모 엔티티가 삭제되지 않더라도, 관계가 끊어진 자식 엔티티는 삭제된다. 관계가 끊어진 \"고아\" 엔티티를 자동으로 삭제하는 기능을 제공한다.\n\n### Cascade.ALL + orphanRemoval =true 인 경우 부모엔티티는 자식엔티티의 모든 라이프사이클을 관리한다.\n\nCascade.ALL + orphanRemoval = true 가 된 경우 부모엔티티에서 자식엔티티의 라이프사이클을 전부 관리 할수 있다.\n\n이 경우 자식엔티티는 별도의 DAO, Repository 등을 생성하지 않고 이런 기능들을 부모엔티티에 넘길 수 있게 된다.\n\n도메인 주도 설계(DDD)의 Aggregate Root 개념을 구현 할 수 있다.\n\n## JPA mappedBy란\n\nmappedBy는 JPA에서 양방향 연관관계를 설정할 때, 연관관계의 주인이 누구인지 설정하는 것이다.\n양방향 연관관계에서만 사용되므로 @OneToMay, @ManyToMany 에서만 설정이 가능하다.\n연관관계의 주인이라는 말은 DB에서 연관관계를 설정하기 위해서는 참조키가 필요한데, 이 참조키를 실제 소유하는 엔티티를 연관관계의 주인 엔티티라 부른다.\n즉 mappedBy 설정이란 이런 양방향 연관관계에서 어떤 엔티티에 실제 연관관계를 위한 참조키를 저장할 것인지를 설정하는 기능이다.\n\n아래 Parent 엔티티에 mappledBy = “parent” 라는 설정의 의미는 **나 Parent 엔티티는 양방향 연관관계의 주인이 아니다.** 라는 의미이다.\n\n나 말고 상대 엔티티인 Children 엔티티가 연관관계의 주인이며, 해당 엔티티의 parent 라는 프로퍼티가 실제 DB에서 참조키를 저장하는 컬럼이다 라고 명시한 것이다.\n\n```java\n@Data\n@Entity\npublic class Parent {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\", nullable = false)\n    private Long id;\n\n    private String name;\n\n    @OneToMany(mappedBy = \"parent\", cascade = CascadeType.ALL)\n    private List<Children> childrenList = new ArrayList<>();\n\n    public void addChildren(Children children){\n        this.childrenList.add(children);\n        children.setParent(this);\n    }\n\n}\nData\n@Entity\npublic class Children {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\", nullable = false)\n    private Long id;\n\n    private String name;\n\n    @ManyToOne\n    @JoinColumn(name=\"parent_id\")\n    private Parent parent;\n}\n```\n\n> mappedBy 사용시 햇갈리는 부분은 연관관계의 주인이 아닌 엔티티에 mappedBy 설정이 들어간다는 것이다.\n> mappedBy 옵션이 보인다면 해당 엔티티의 반대편 엔티티가 연관관계의 주인이며, 그 주인 엔티티에 실제 FK 가 저장된다.\n\n### 연관관계 주인의 권한 : 연관관계를 설정할 수 있는 권한은 연관관계 주인이 갖는다.\n\n위 예제에서 연관관계의 주인은 Children이다. 즉 Children 엔티티에서 setParent 호출만이 실제 연관관계를 설정하게 된다.\n\n아래 Parent 부모엔티티의 addChildren 메소드를 보면 children.setParent 를 호출하는 것을 볼 수 있다. 만약 children.setParen 호출하지 않게 되면, Parent, Children 엔티티는 DB에 저장되지만 연관관계 없이 저장되게 된다.\n\n```java\npublic void addChildren(Children children){\n        this.childrenList.add(children);\n        children.setParent(this);\n}\n```\n\n## 난 왜 Cascade와 mappedBy가 혼동되는가\n\n혼동을 테스트할 예제를 준비하겠다.\n\n엔티티\n\n```java\n\n@Data\n@Entity\npublic class Parent {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\", nullable = false)\n    private Long id;\n\n    private String name;\n\n    @OneToMany(mappedBy = \"parent\", orphanRemoval = true)\n    private List<Children> childrenList = new ArrayList<>();\n\n    public void addChildren(Children children){\n        this.childrenList.add(children);\n        children.setParent(this);\n    }\n\n    public void removeChildren(Children children){\n        this.childrenList.remove(children);\n        children.setParent(null);\n    }\n}\n\n@Data\n@Entity\npublic class Children {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\", nullable = false)\n    private Long id;\n\n    private String name;\n\n    @ManyToOne\n    @JoinColumn(name=\"parent_id\")\n    private Parent parent;\n}\n\n```\n\n테스트 코드\n\n```java\n// 테스트 코드\n\n```\n\n### 혼동1.\n\n### 혼동2.\n\n## 정리\n\n- Cascade와 mappedby 는 혼동될 것이 없다.\n- Cascade는 영속성라이프사이클에 관련된 어떤 이벤트가 발생시 그 이벤트를 자식 엔티티에 전파할것인지에 대한 설정이다.\n- mappedBy는 양방향 연관관계에서 연관관계의 주인을 명시하는 설정이다.\n- mappedBy와 orphanRemoval = true를 같이 사용하면, 부모엔티티에서 연관관계 도우미?메소드를 통해 쉽게 제거 할수 있다.\n- Cascade.ALL + orphanRemoval =true 같이 사용하면, 부모엔티티에서 자식엔티티의 라이프사이클을 완전히 컨트롤 할 수 있다.\n  - 자식엔티티의 DAO, repository를 만들지 않을 수도 있다.\n\n## 참고자료\n\n- 인프런 - 자바 ORM 표준 JPA 프로그래밍 -기본편 (김영환)\n- 책 - 자바 ORM 표준 JPA 프로그래밍 (김영환)\n- chatGPT\n","slug":"/post/jpa_cascade_vs_mappedby/"}]}